Sat Sep 19 16:36:27 PDT 2020
Linux csslab1.uwb.edu 3.10.0-1127.19.1.el7.x86_64 #1 SMP Tue Aug 25 17:23:54 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux
uid=870540(pisan) gid=2120870540(pisan) groups=2120870540(pisan),579804(faculty)
=====================================================
1. Compiles without warnings with -Wall -Wextra flags
=====================================================
=====================================================
2. Runs and produces correct output
=====================================================
Done.
=====================================================
3. clang-tidy warnings are fixed
=====================================================
11351 warnings generated.
22254 warnings generated.
Suppressed 22254 warnings (22254 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.
=====================================================
4. clang-format does not find any formatting issues
=====================================================
Running clang-format on ./main.cpp
Running clang-format on ./rational.cpp
=====================================================
5. No memory leaks using g++
=====================================================
=====================================================
6. No memory leaks using valgrind, look for "definitely lost" 
=====================================================
==6496== Memcheck, a memory error detector
==6496== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==6496== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==6496== Command: ./a.out
==6496== Parent PID: 6442
==6496== 
==6496== 
==6496== HEAP SUMMARY:
==6496==     in use at exit: 0 bytes in 0 blocks
==6496==   total heap usage: 1 allocs, 1 frees, 72,704 bytes allocated
==6496== 
==6496== All heap blocks were freed -- no leaks are possible
==6496== 
==6496== For lists of detected and suppressed errors, rerun with: -s
==6496== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
=====================================================
7. Tests have full code coverage
=====================================================
File '/home/NETID/pisan/bitbucket/pisan342/rational/main.cpp':
Name                        Regions    Miss   Cover     Lines    Miss   Cover
-----------------------------------------------------------------------------
test1()                           1       0 100.00%        11       0 100.00%
test2()                           1       0 100.00%        19       0 100.00%
test3()                           1       0 100.00%        26       0 100.00%
test4()                           1       0 100.00%        32       0 100.00%
main                              1       0 100.00%        12       0 100.00%
-----------------------------------------------------------------------------
TOTAL                             5       0 100.00%       100       0 100.00%

File '/home/NETID/pisan/bitbucket/pisan342/rational/rational.cpp':
Name                                          Regions    Miss   Cover     Lines    Miss   Cover
-----------------------------------------------------------------------------------------------
Rational::Rational()                                1       0 100.00%         1       0 100.00%
Rational::Rational(int)                             1       0 100.00%         1       0 100.00%
Rational::Rational(int, int)                        3       0 100.00%        10       0 100.00%
Rational::operator int() const                      1       0 100.00%         1       0 100.00%
Rational::operator+(Rational const&) const          1       0 100.00%         6       0 100.00%
Rational::operator-(Rational const&) const          1       0 100.00%         6       0 100.00%
Rational::operator*(Rational const&) const          1       0 100.00%         6       0 100.00%
Rational::operator/(Rational const&) const          3       0 100.00%        10       0 100.00%
Rational::operator>(Rational const&) const          1       0 100.00%         3       0 100.00%
Rational::operator<(Rational const&) const          1       0 100.00%         3       0 100.00%
Rational::operator>=(Rational const&) const         3       0 100.00%         3       0 100.00%
Rational::operator<=(Rational const&) const         3       0 100.00%         3       0 100.00%
Rational::operator==(Rational const&) const         3       0 100.00%         3       0 100.00%
Rational::operator!=(Rational const&) const         1       0 100.00%         3       0 100.00%
Rational::operator+=(Rational const&)               1       0 100.00%         6       0 100.00%
Rational::operator-=(Rational const&)               1       0 100.00%         6       0 100.00%
Rational::operator*=(Rational const&)               1       0 100.00%         6       0 100.00%
Rational::operator/=(Rational const&)               1       0 100.00%         6       0 100.00%
operator<<(std::ostream&, Rational const&)          7       0 100.00%        11       0 100.00%
operator>>(std::istream&, Rational&)                3       0 100.00%        10       0 100.00%
Rational::reduce()                                 10       0 100.00%        19       0 100.00%
-----------------------------------------------------------------------------------------------
TOTAL                                              48       0 100.00%       123       0 100.00%
/home/NETID/pisan/bitbucket/pisan342/rational/main.cpp:
    1|       |#include <cassert>
    2|       |#include <iostream>
    3|       |#include <sstream>
    4|       |
    5|       |#include "rational.h"
    6|       |
    7|       |using namespace std;
    8|       |
    9|       |// testing comparison
   10|      1|void test1() {
   11|      1|  Rational r12(1, 2);
   12|      1|  Rational r23(2, 3);
   13|      1|  assert(r23 > r12);
   14|      1|  assert(r23 >= r12);
   15|      1|  assert(r12 < r23);
   16|      1|  assert(r12 <= r23);
   17|      1|  assert(r12 != r23);
   18|      1|  Rational r48(4, 8);
   19|      1|  assert(r12 == r48);
   20|      1|}
   21|       |
   22|       |// testing arithmetic
   23|      1|void test2() {
   24|      1|  stringstream ss;
   25|      1|  Rational r12(1, 2);
   26|      1|  Rational r23(2, 3);
   27|      1|  ss << r12 + r23;
   28|      1|  assert(ss.str() == "7/6");
   29|      1|
   30|      1|  ss.str("");
   31|      1|  ss << r12 - r23;
   32|      1|  assert(ss.str() == "-1/6");
   33|      1|
   34|      1|  ss.str("");
   35|      1|  ss << r12 * r23;
   36|      1|  assert(ss.str() == "1/3");
   37|      1|
   38|      1|  ss.str("");
   39|      1|  ss << r12 / r23;
   40|      1|  assert(ss.str() == "3/4");
   41|      1|}
   42|       |
   43|       |// testing assignment operators
   44|      1|void test3() {
   45|      1|  stringstream ss;
   46|      1|  Rational r12(1, 2);
   47|      1|  Rational r23(2, 3);
   48|      1|  r12 += r23;
   49|      1|  ss << r12;
   50|      1|  assert(ss.str() == "7/6");
   51|      1|
   52|      1|  ss.str("");
   53|      1|  r12 = Rational(1, 2);
   54|      1|  r12 -= r23;
   55|      1|  ss << r12;
   56|      1|  assert(ss.str() == "-1/6");
   57|      1|
   58|      1|  ss.str("");
   59|      1|  r12 = Rational(1, 2);
   60|      1|  r12 *= r23;
   61|      1|  ss << r12;
   62|      1|  assert(ss.str() == "1/3");
   63|      1|
   64|      1|  ss.str("");
   65|      1|  r12 = Rational(1, 2);
   66|      1|  r12 /= r23;
   67|      1|  ss << r12;
   68|      1|  assert(ss.str() == "3/4");
   69|      1|}
   70|       |
   71|       |// test miscellaneous
   72|      1|void test4() {
   73|      1|  stringstream ss;
   74|      1|  Rational r(-1, -2);
   75|      1|  ss << r;
   76|      1|  assert(ss.str() == "1/2");
   77|      1|
   78|      1|  ss.str("");
   79|      1|  istringstream toRead("-20 -70");
   80|      1|  toRead >> r;
   81|      1|  ss << r;
   82|      1|  assert(ss.str() == "2/7");
   83|      1|
   84|      1|  ss.str("");
   85|      1|  Rational r10(10);
   86|      1|  r *= r10;
   87|      1|  ss << r;
   88|      1|  assert(ss.str() == "20/7");
   89|      1|
   90|      1|  // same as old style casting using (int)
   91|      1|  int num = static_cast<int>(r);
   92|      1|  assert(num == 2);
   93|      1|
   94|      1|  ss.str("");
   95|      1|  Rational whole(7, 1);
   96|      1|  ss << whole;
   97|      1|  assert(ss.str() == "7");
   98|      1|
   99|      1|  ss.str("");
  100|      1|  Rational zero(0, 10);
  101|      1|  ss << zero;
  102|      1|  assert(ss.str() == "0");
  103|      1|}
  104|       |
  105|      1|int main() {
  106|      1|  test1();
  107|      1|  test2();
  108|      1|  test3();
  109|      1|  test4();
  110|      1|  // Rational r1(1, 16);
  111|      1|  // Rational r2(4);
  112|      1|  // Rational r3 = r1 + r2;
  113|      1|  // cout << "r3: " << r3 << endl;
  114|      1|  cout << "Done." << endl;
  115|      1|  return 0;
  116|      1|}

/home/NETID/pisan/bitbucket/pisan342/rational/rational.cpp:
    1|       |// a Rational object holds one Rational number, one fraction
    2|       |// Example from Deitel and Deitel: C++ How To Program
    3|       |
    4|       |#include "rational.h"
    5|       |#include <cassert>
    6|       |
    7|       |// default constructor using member values
    8|      1|Rational::Rational() = default;
    9|       |
   10|       |// constructor with numberator only, denominator defaults to 1
   11|      1|Rational::Rational(int numerator) : numerator{numerator} {}
   12|       |
   13|       |// constructor with numberator and denominator
   14|       |Rational::Rational(int aNumerator, int aDenominator)
   15|     16|    : numerator{aNumerator}, denominator{aDenominator} {
   16|     16|  assert(denominator != 0);
   17|     16|  // If denominator is negative, flip both
   18|     16|  if (aDenominator < 0) {
   19|      1|    numerator = -aNumerator;
   20|      1|    denominator = -aDenominator;
   21|      1|  }
   22|     16|  // to lowest terms
   23|     16|  reduce();
   24|     16|}
   25|       |
   26|      1|Rational::operator int() const { return numerator / denominator; }
   27|       |//----------------------------------------------------------------------------
   28|       |// operator+
   29|       |// overloaded +: addition of 2 Rationals, current object and parameter
   30|       |// Result is reduced to lowest terms.
   31|       |
   32|      1|Rational Rational::operator+(const Rational &other) const {
   33|      1|  int n = other.numerator * denominator + other.denominator * numerator;
   34|      1|  int d = other.denominator * denominator;
   35|      1|  Rational result(n, d);
   36|      1|  return result;
   37|      1|}
   38|       |
   39|       |//----------------------------------------------------------------------------
   40|       |// operator-
   41|       |// overloaded -: subtraction of 2 Rationals, current object and parameter
   42|       |// Result is reduced to lowest terms.
   43|       |
   44|      1|Rational Rational::operator-(const Rational &other) const {
   45|      1|  int n = other.denominator * numerator - denominator * other.numerator;
   46|      1|  int d = other.denominator * denominator;
   47|      1|  Rational result(n, d);
   48|      1|  return result;
   49|      1|}
   50|       |
   51|       |// overloaded *: multiplication of 2 Rationals, current object and parameter
   52|      1|Rational Rational::operator*(const Rational &other) const {
   53|      1|  int n = other.numerator * numerator;
   54|      1|  int d = other.denominator * denominator;
   55|      1|  Rational result(n, d);
   56|      1|  return result;
   57|      1|}
   58|       |
   59|       |// overloaded /: division of 2 Rationals
   60|      1|Rational Rational::operator/(const Rational &other) const {
   61|      1|  Rational div;
   62|      1|  // make sure new denominator is not zero
   63|      1|  if (other.numerator != 0) {
   64|      1|    div.numerator = other.denominator * numerator;
   65|      1|    div.denominator = denominator * other.numerator;
   66|      1|    div.reduce();
   67|      1|  }
   68|      1|  return div;
   69|      1|}
   70|       |
   71|       |// overloaded >: true if current object is > parameter, otherwise false
   72|      2|bool Rational::operator>(const Rational &other) const {
   73|      2|  return numerator * other.denominator > other.numerator * denominator;
   74|      2|}
   75|       |
   76|       |// overloaded <: true if current object is < parameter, otherwise false
   77|      2|bool Rational::operator<(const Rational &other) const {
   78|      2|  return numerator * other.denominator < other.numerator * denominator;
   79|      2|}
   80|       |
   81|       |// overloaded >=: true if current object is >= parameter, otherwise false
   82|      1|bool Rational::operator>=(const Rational &other) const {
   83|      1|  return *this == other || *this > other;
   84|      1|}
   85|       |
   86|       |// overloaded <=: true if current object is <= parameter, otherwise false
   87|      1|bool Rational::operator<=(const Rational &other) const {
   88|      1|  return *this == other || *this < other;
   89|      1|}
   90|       |
   91|       |// overloaded ==: true if current object is == parameter, otherwise false
   92|      4|bool Rational::operator==(const Rational &other) const {
   93|      4|  return numerator == other.numerator && denominator == other.denominator;
   94|      4|}
   95|       |
   96|       |// overloaded !=: true if current object is != parameter, otherwise false
   97|      1|bool Rational::operator!=(const Rational &other) const {
   98|      1|  return !(*this == other);
   99|      1|}
  100|       |
  101|       |// overloaded +=: current object = current object + parameter
  102|      1|Rational &Rational::operator+=(const Rational &other) {
  103|      1|  numerator = other.numerator * denominator + other.denominator * numerator;
  104|      1|  denominator *= other.denominator;
  105|      1|  reduce();
  106|      1|  return *this;
  107|      1|}
  108|       |
  109|       |// overloaded -=: current object = current object - parameter
  110|      1|Rational &Rational::operator-=(const Rational &other) {
  111|      1|  numerator = numerator * other.denominator - other.numerator * denominator;
  112|      1|  denominator *= other.denominator;
  113|      1|  reduce();
  114|      1|  return *this;
  115|      1|}
  116|       |
  117|       |// overloaded *=: current object = current object * parameter
  118|      2|Rational &Rational::operator*=(const Rational &other) {
  119|      2|  numerator *= other.numerator;
  120|      2|  denominator *= other.denominator;
  121|      2|  reduce();
  122|      2|  return *this;
  123|      2|}
  124|       |
  125|       |// overloaded /=: current object = current object / parameter
  126|      1|Rational &Rational::operator/=(const Rational &other) {
  127|      1|  numerator *= other.denominator;
  128|      1|  denominator *= other.numerator;
  129|      1|  reduce();
  130|      1|  return *this;
  131|      1|}
  132|       |
  133|       |//----------------------------------------------------------------------------
  134|       |// operator<<
  135|       |// overloaded <<: prints "DIVIDE BY ZERO ERROR!!!" if Denominator is zero,
  136|       |//    prints whole numbers without Denominator (as ints), otherwise uses '/'
  137|     13|ostream &operator<<(ostream &output, const Rational &r) {
  138|     13|  assert(r.denominator != 0);
  139|     13|  if (r.numerator == 0) {
  140|      1|    return output << 0;
  141|      1|  }
  142|     12|  if (r.denominator == 1) {
  143|      1|    // whole number
  144|      1|    return output << r.numerator;
  145|      1|  }
  146|     11|  return output << r.numerator << "/" << r.denominator;
  147|     11|}
  148|       |
  149|       |// overloaded >>: takes 2 ints as Numerator and Denominator,
  150|       |// does not do any error checking
  151|      1|istream &operator>>(istream &input, Rational &r) {
  152|      1|  input >> r.numerator >> r.denominator;
  153|      1|  assert(r.denominator != 0);
  154|      1|  if (r.denominator < 0) {
  155|      1|    r.numerator = -r.numerator;
  156|      1|    r.denominator = -r.denominator;
  157|      1|  }
  158|      1|  r.reduce();
  159|      1|  return input;
  160|      1|}
  161|       |
  162|       |// reduce fraction to lowest terms
  163|     23|void Rational::reduce() {
  164|     23|  // if numerator is 0, set denominator to be always 1
  165|     23|  if (numerator == 0) {
  166|      1|    denominator = 1;
  167|      1|    return;
  168|      1|  }
  169|     22|  // make Numerator positive
  170|     22|  int n = numerator < 0 ? -numerator : numerator;
  171|     22|
  172|     22|  // greatest common divisor
  173|     22|  int gcd = min(n, denominator);
  174|     22|
  175|     55|  while (n % gcd != 0 || denominator % gcd != 0) {
  176|     33|    --gcd;
  177|     33|  }
  178|     22|
  179|     22|  numerator /= gcd;
  180|     22|  denominator /= gcd;
  181|     22|}

Sat Sep 19 16:36:36 PDT 2020
=====================================================
To create an output.txt file with all the output from this script
Run the below command
      ./create-output.sh > output.txt 2>&1 
=====================================================
