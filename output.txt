Mon Sep 28 08:10:28 PDT 2020
Linux csslab1.uwb.edu 3.10.0-1127.19.1.el7.x86_64 #1 SMP Tue Aug 25 17:23:54 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux
uid=870540(pisan) gid=2120870540(pisan) groups=2120870540(pisan),579804(faculty)
=====================================================
1. Compiles without warnings with -Wall -Wextra flags
=====================================================
=====================================================
2. Runs and produces correct output
=====================================================
Done.
=====================================================
3. clang-tidy warnings are fixed
=====================================================
11351 warnings generated.
22254 warnings generated.
Suppressed 22254 warnings (22254 in non-user code).
Use -header-filter=.* to display errors from all non-system headers. Use -system-headers to display errors from system headers as well.
=====================================================
4. clang-format does not find any formatting issues
=====================================================
Running clang-format on ./main.cpp
Running clang-format on ./rational.cpp
=====================================================
5. No memory leaks using g++
=====================================================
=====================================================
6. No memory leaks using valgrind, look for "definitely lost" 
=====================================================
==18550== Memcheck, a memory error detector
==18550== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==18550== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==18550== Command: ./a.out
==18550== Parent PID: 18502
==18550== 
==18550== 
==18550== HEAP SUMMARY:
==18550==     in use at exit: 0 bytes in 0 blocks
==18550==   total heap usage: 1 allocs, 1 frees, 72,704 bytes allocated
==18550== 
==18550== All heap blocks were freed -- no leaks are possible
==18550== 
==18550== For lists of detected and suppressed errors, rerun with: -s
==18550== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
=====================================================
7. Tests have full code coverage
=====================================================
File '/home/NETID/pisan/bitbucket/pisan342/rational/main.cpp':
Name                        Regions    Miss   Cover     Lines    Miss   Cover
-----------------------------------------------------------------------------
test1()                           1       0 100.00%        11       0 100.00%
test2()                           1       0 100.00%        19       0 100.00%
test3()                           1       0 100.00%        18       0 100.00%
test4()                           1       0 100.00%        28       0 100.00%
main                              1       0 100.00%        12       0 100.00%
-----------------------------------------------------------------------------
TOTAL                             5       0 100.00%        88       0 100.00%

File '/home/NETID/pisan/bitbucket/pisan342/rational/rational.cpp':
Name                                          Regions    Miss   Cover     Lines    Miss   Cover
-----------------------------------------------------------------------------------------------
Rational::Rational()                                1       0 100.00%         1       0 100.00%
Rational::Rational(int)                             1       0 100.00%         1       0 100.00%
Rational::Rational(int, int)                        3       0 100.00%        10       0 100.00%
Rational::getNumerator() const                      1       0 100.00%         1       0 100.00%
Rational::getDenominator() const                    1       0 100.00%         1       0 100.00%
Rational::operator int() const                      1       0 100.00%         1       0 100.00%
Rational::operator+(Rational const&) const          1       0 100.00%         6       0 100.00%
Rational::operator-(Rational const&) const          1       0 100.00%         6       0 100.00%
Rational::operator*(Rational const&) const          1       0 100.00%         6       0 100.00%
Rational::operator/(Rational const&) const          3       0 100.00%        10       0 100.00%
Rational::operator>(Rational const&) const          1       0 100.00%         3       0 100.00%
Rational::operator<(Rational const&) const          1       0 100.00%         3       0 100.00%
Rational::operator>=(Rational const&) const         3       0 100.00%         3       0 100.00%
Rational::operator<=(Rational const&) const         3       0 100.00%         3       0 100.00%
Rational::operator==(Rational const&) const         3       0 100.00%         3       0 100.00%
Rational::operator!=(Rational const&) const         1       0 100.00%         3       0 100.00%
Rational::operator+=(Rational const&)               1       0 100.00%         6       0 100.00%
Rational::operator-=(Rational const&)               1       0 100.00%         6       0 100.00%
Rational::operator*=(Rational const&)               1       0 100.00%         6       0 100.00%
Rational::operator/=(Rational const&)               1       0 100.00%         6       0 100.00%
operator<<(std::ostream&, Rational const&)          7       0 100.00%        11       0 100.00%
operator>>(std::istream&, Rational&)                3       0 100.00%        10       0 100.00%
Rational::reduce()                                 10       0 100.00%        19       0 100.00%
-----------------------------------------------------------------------------------------------
TOTAL                                              50       0 100.00%       125       0 100.00%
/home/NETID/pisan/bitbucket/pisan342/rational/main.cpp:
    1|       |#include <cassert>
    2|       |#include <iostream>
    3|       |#include <sstream>
    4|       |
    5|       |#include "rational.h"
    6|       |
    7|       |using namespace std;
    8|       |
    9|       |// testing comparison
   10|      1|void test1() {
   11|      1|  Rational r12(1, 2);
   12|      1|  Rational r23(2, 3);
   13|      1|  assert(r23 > r12);
   14|      1|  assert(r23 >= r12);
   15|      1|  assert(r12 < r23);
   16|      1|  assert(r12 <= r23);
   17|      1|  assert(r12 != r23);
   18|      1|  Rational r48(4, 8);
   19|      1|  assert(r12 == r48);
   20|      1|}
   21|       |
   22|       |// testing arithmetic
   23|      1|void test2() {
   24|      1|  stringstream ss;
   25|      1|  Rational r12(1, 2);
   26|      1|  Rational r23(2, 3);
   27|      1|  ss << r12 + r23;
   28|      1|  assert(ss.str() == "7/6");
   29|      1|
   30|      1|  ss.str("");
   31|      1|  ss << r12 - r23;
   32|      1|  assert(ss.str() == "-1/6");
   33|      1|
   34|      1|  ss.str("");
   35|      1|  ss << r12 * r23;
   36|      1|  assert(ss.str() == "1/3");
   37|      1|
   38|      1|  ss.str("");
   39|      1|  ss << r12 / r23;
   40|      1|  assert(ss.str() == "3/4");
   41|      1|}
   42|       |
   43|       |// testing assignment operators
   44|      1|void test3() {
   45|      1|  Rational r12(1, 2);
   46|      1|  Rational r23(2, 3);
   47|      1|  r12 += r23;
   48|      1|  assert(r12.getNumerator() == 7 && r12.getDenominator() == 6);
   49|      1|
   50|      1|  r12 = Rational(1, 2);
   51|      1|  r12 -= r23;
   52|      1|  assert(r12.getNumerator() == -1 && r12.getDenominator() == 6);
   53|      1|
   54|      1|  r12 = Rational(1, 2);
   55|      1|  r12 *= r23;
   56|      1|  assert(r12.getNumerator() == 1 && r12.getDenominator() == 3);
   57|      1|
   58|      1|  r12 = Rational(1, 2);
   59|      1|  r12 /= r23;
   60|      1|  assert(r12.getNumerator() == 3 && r12.getDenominator() == 4);
   61|      1|}
   62|       |
   63|       |// test miscellaneous
   64|      1|void test4() {
   65|      1|  Rational r(-1, -2);
   66|      1|  assert(r.getNumerator() == 1 && r.getDenominator() == 2);
   67|      1|
   68|      1|  istringstream toRead("-20 -70");
   69|      1|  toRead >> r;
   70|      1|  assert(r.getNumerator() == 2 && r.getDenominator() == 7);
   71|      1|
   72|      1|  Rational r10(10);
   73|      1|  r *= r10;
   74|      1|  assert(r.getNumerator() == 20 && r.getDenominator() == 7);
   75|      1|
   76|      1|  // same as old style casting using (int)
   77|      1|  int num = static_cast<int>(r);
   78|      1|  assert(num == 2);
   79|      1|
   80|      1|  stringstream ss;
   81|      1|  Rational whole(7, 1);
   82|      1|  ss << whole;
   83|      1|  assert(whole.getNumerator() == 7 && whole.getDenominator() == 1);
   84|      1|  assert(ss.str() == "7");
   85|      1|
   86|      1|  ss.str("");
   87|      1|  Rational zero(0, 10);
   88|      1|  ss << zero;
   89|      1|  assert(zero.getNumerator() == 0 && zero.getDenominator() == 1);
   90|      1|  assert(ss.str() == "0");
   91|      1|}
   92|       |
   93|      1|int main() {
   94|      1|  test1();
   95|      1|  test2();
   96|      1|  test3();
   97|      1|  test4();
   98|      1|  // Rational r1(1, 16);
   99|      1|  // Rational r2(4);
  100|      1|  // Rational r3 = r1 + r2;
  101|      1|  // cout << "r3: " << r3 << endl;
  102|      1|  cout << "Done." << endl;
  103|      1|  return 0;
  104|      1|}

/home/NETID/pisan/bitbucket/pisan342/rational/rational.cpp:
    1|       |// a Rational object holds one Rational number, one fraction
    2|       |// Example from Deitel and Deitel: C++ How To Program
    3|       |
    4|       |#include "rational.h"
    5|       |#include <cassert>
    6|       |
    7|       |// default constructor using member values
    8|      1|Rational::Rational() = default;
    9|       |
   10|       |// constructor with numberator only, denominator defaults to 1
   11|      1|Rational::Rational(int numerator) : numerator{numerator} {}
   12|       |
   13|       |// constructor with numberator and denominator
   14|       |Rational::Rational(int aNumerator, int aDenominator)
   15|     16|    : numerator{aNumerator}, denominator{aDenominator} {
   16|     16|  assert(denominator != 0);
   17|     16|  // If denominator is negative, flip both
   18|     16|  if (aDenominator < 0) {
   19|      1|    numerator = -aNumerator;
   20|      1|    denominator = -aDenominator;
   21|      1|  }
   22|     16|  // to lowest terms
   23|     16|  reduce();
   24|     16|}
   25|       |
   26|       |// accessor for numerator
   27|      9|int Rational::getNumerator() const { return numerator; }
   28|       |
   29|       |// accessor for denominator
   30|      9|int Rational::getDenominator() const { return denominator; }
   31|       |
   32|      1|Rational::operator int() const { return numerator / denominator; }
   33|       |//----------------------------------------------------------------------------
   34|       |// operator+
   35|       |// overloaded +: addition of 2 Rationals, current object and parameter
   36|       |// Result is reduced to lowest terms.
   37|       |
   38|      1|Rational Rational::operator+(const Rational &other) const {
   39|      1|  int n = other.numerator * denominator + other.denominator * numerator;
   40|      1|  int d = other.denominator * denominator;
   41|      1|  Rational result(n, d);
   42|      1|  return result;
   43|      1|}
   44|       |
   45|       |//----------------------------------------------------------------------------
   46|       |// operator-
   47|       |// overloaded -: subtraction of 2 Rationals, current object and parameter
   48|       |// Result is reduced to lowest terms.
   49|       |
   50|      1|Rational Rational::operator-(const Rational &other) const {
   51|      1|  int n = other.denominator * numerator - denominator * other.numerator;
   52|      1|  int d = other.denominator * denominator;
   53|      1|  Rational result(n, d);
   54|      1|  return result;
   55|      1|}
   56|       |
   57|       |// overloaded *: multiplication of 2 Rationals, current object and parameter
   58|      1|Rational Rational::operator*(const Rational &other) const {
   59|      1|  int n = other.numerator * numerator;
   60|      1|  int d = other.denominator * denominator;
   61|      1|  Rational result(n, d);
   62|      1|  return result;
   63|      1|}
   64|       |
   65|       |// overloaded /: division of 2 Rationals
   66|      1|Rational Rational::operator/(const Rational &other) const {
   67|      1|  Rational div;
   68|      1|  // make sure new denominator is not zero
   69|      1|  if (other.numerator != 0) {
   70|      1|    div.numerator = other.denominator * numerator;
   71|      1|    div.denominator = denominator * other.numerator;
   72|      1|    div.reduce();
   73|      1|  }
   74|      1|  return div;
   75|      1|}
   76|       |
   77|       |// overloaded >: true if current object is > parameter, otherwise false
   78|      2|bool Rational::operator>(const Rational &other) const {
   79|      2|  return numerator * other.denominator > other.numerator * denominator;
   80|      2|}
   81|       |
   82|       |// overloaded <: true if current object is < parameter, otherwise false
   83|      2|bool Rational::operator<(const Rational &other) const {
   84|      2|  return numerator * other.denominator < other.numerator * denominator;
   85|      2|}
   86|       |
   87|       |// overloaded >=: true if current object is >= parameter, otherwise false
   88|      1|bool Rational::operator>=(const Rational &other) const {
   89|      1|  return *this == other || *this > other;
   90|      1|}
   91|       |
   92|       |// overloaded <=: true if current object is <= parameter, otherwise false
   93|      1|bool Rational::operator<=(const Rational &other) const {
   94|      1|  return *this == other || *this < other;
   95|      1|}
   96|       |
   97|       |// overloaded ==: true if current object is == parameter, otherwise false
   98|      4|bool Rational::operator==(const Rational &other) const {
   99|      4|  return numerator == other.numerator && denominator == other.denominator;
  100|      4|}
  101|       |
  102|       |// overloaded !=: true if current object is != parameter, otherwise false
  103|      1|bool Rational::operator!=(const Rational &other) const {
  104|      1|  return !(*this == other);
  105|      1|}
  106|       |
  107|       |// overloaded +=: current object = current object + parameter
  108|      1|Rational &Rational::operator+=(const Rational &other) {
  109|      1|  numerator = other.numerator * denominator + other.denominator * numerator;
  110|      1|  denominator *= other.denominator;
  111|      1|  reduce();
  112|      1|  return *this;
  113|      1|}
  114|       |
  115|       |// overloaded -=: current object = current object - parameter
  116|      1|Rational &Rational::operator-=(const Rational &other) {
  117|      1|  numerator = numerator * other.denominator - other.numerator * denominator;
  118|      1|  denominator *= other.denominator;
  119|      1|  reduce();
  120|      1|  return *this;
  121|      1|}
  122|       |
  123|       |// overloaded *=: current object = current object * parameter
  124|      2|Rational &Rational::operator*=(const Rational &other) {
  125|      2|  numerator *= other.numerator;
  126|      2|  denominator *= other.denominator;
  127|      2|  reduce();
  128|      2|  return *this;
  129|      2|}
  130|       |
  131|       |// overloaded /=: current object = current object / parameter
  132|      1|Rational &Rational::operator/=(const Rational &other) {
  133|      1|  numerator *= other.denominator;
  134|      1|  denominator *= other.numerator;
  135|      1|  reduce();
  136|      1|  return *this;
  137|      1|}
  138|       |
  139|       |//----------------------------------------------------------------------------
  140|       |// operator<<
  141|       |// overloaded <<: prints "DIVIDE BY ZERO ERROR!!!" if Denominator is zero,
  142|       |//    prints whole numbers without Denominator (as ints), otherwise uses '/'
  143|      6|ostream &operator<<(ostream &output, const Rational &r) {
  144|      6|  assert(r.denominator != 0);
  145|      6|  if (r.numerator == 0) {
  146|      1|    return output << 0;
  147|      1|  }
  148|      5|  if (r.denominator == 1) {
  149|      1|    // whole number
  150|      1|    return output << r.numerator;
  151|      1|  }
  152|      4|  return output << r.numerator << "/" << r.denominator;
  153|      4|}
  154|       |
  155|       |// overloaded >>: takes 2 ints as Numerator and Denominator,
  156|       |// does not do any error checking
  157|      1|istream &operator>>(istream &input, Rational &r) {
  158|      1|  input >> r.numerator >> r.denominator;
  159|      1|  assert(r.denominator != 0);
  160|      1|  if (r.denominator < 0) {
  161|      1|    r.numerator = -r.numerator;
  162|      1|    r.denominator = -r.denominator;
  163|      1|  }
  164|      1|  r.reduce();
  165|      1|  return input;
  166|      1|}
  167|       |
  168|       |// reduce fraction to lowest terms
  169|     23|void Rational::reduce() {
  170|     23|  // if numerator is 0, set denominator to be always 1
  171|     23|  if (numerator == 0) {
  172|      1|    denominator = 1;
  173|      1|    return;
  174|      1|  }
  175|     22|  // make Numerator positive
  176|     22|  int n = numerator < 0 ? -numerator : numerator;
  177|     22|
  178|     22|  // greatest common divisor
  179|     22|  int gcd = min(n, denominator);
  180|     22|
  181|     55|  while (n % gcd != 0 || denominator % gcd != 0) {
  182|     33|    --gcd;
  183|     33|  }
  184|     22|
  185|     22|  numerator /= gcd;
  186|     22|  denominator /= gcd;
  187|     22|}

Mon Sep 28 08:10:37 PDT 2020
=====================================================
To create an output.txt file with all the output from this script
Run the below command
      ./create-output.sh > output.txt 2>&1 
=====================================================
